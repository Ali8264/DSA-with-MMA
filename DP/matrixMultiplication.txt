Matrix Chain Multiplication (MCM) is the father of interval DP problems.
Matrix Chain Multiplication (MCM)
You are given an array arr[] of size N.
The i-th matrix has dimensions
üëâ (arr[i-1] √ó arr[i])
You must multiply all matrices in order
You can add brackets anywhere
Goal: minimize total scalar multiplications
‚ö†Ô∏è Matrix multiplication is associative but NOT commutative

---------------------(Intuition)

Different parenthesizations ‚Üí different costs.
üëâ We must decide where to split the matrix chain.
This is a Partition / Interval DP problem.
-----------
Why Greedy / Brute Force Fails ‚ùå
Number of ways to parenthesize grows exponentially
We must try all possible partitions smartly using DP

DP State Definition
dp[i][j] = minimum number of scalar multiplications
           needed to multiply matrices from i to j


Here:
Matrix Mi has dimension arr[i-1] √ó arr[i]
i and j refer to matrix indices, not array indices
DP Meaning (Very Important)
dp[i][j] represents the minimum cost to multiply
the chain of matrices Mi √ó Mi+1 √ó ... √ó Mj

How to Explain in Interview (Say This)

‚ÄúMatrix Chain Multiplication is an interval DP problem.
I define dp[i][j] as the minimum cost to multiply matrices from i to j.
For every possible partition k, I compute left cost, right cost, and the multiplication cost, and take the minimum.‚Äù


----------------------Interviewer-----------------
If interviewer wants very short explanation, say this:

‚ÄúMatrix Chain Multiplication is an interval DP problem.
I define f(i, j) as the minimum cost to multiply matrices from i to j.
I try all split points k and compute left cost, right cost, and multiplication cost.
Using memoization, the solution runs in O(N¬≥) time.‚Äù

--------------- Memoization (Top-Down DP) ---------------
int solve(int i, int j, vector<int>& arr, vector<vector<int>>& dp) {
    if (i == j) return 0;

    if (dp[i][j] != -1) return dp[i][j];

    int ans = INT_MAX;

    for (int k = i; k < j; k++) {
        int cost = solve(i, k, arr, dp)
                 + solve(k + 1, j, arr, dp)
                 + arr[i - 1] * arr[k] * arr[j];

        ans = min(ans, cost);
    }

    return dp[i][j] = ans;
}

int matrixMultiplication(vector<int>& arr) {
    int n = arr.size();
    vector<vector<int>> dp(n, vector<int>(n, -1));
    return solve(1, n - 1, arr, dp);
}

-------------------Time Complexity---------------
Input:
arr = [2, 1, 3, 4]


Matrices:

M1 = 2√ó1

M2 = 1√ó3

M3 = 3√ó4

Possible splits:

1Ô∏è‚É£ (M1 √ó M2) √ó M3

(2√ó1√ó3) + (2√ó3√ó4) = 30


2Ô∏è‚É£ M1 √ó (M2 √ó M3)

(1√ó3√ó4) + (2√ó1√ó4) = 20 ‚úÖ


‚úî Answer = 20

Time & Space Complexity
Metric	Value
Time	O(N¬≥)
Space	O(N¬≤)